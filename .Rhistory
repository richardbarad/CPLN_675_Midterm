geom_sf(data=grid7,aes(fill=outcome),color='transparent')+
scale_fill_manual(values=c('#fc9c9c','lightblue'),name='',labels=c('No Flood','Flood'))+
theme_void()+
ggtitle('Predictions for Calgary'),
ggplot()+
geom_sf(data=grid6_den,aes(fill=outcome),color='transparent')+
scale_fill_manual(values=c('#fc9c9c','lightblue'),name='',labels=c('No Flood','Flood'))+
theme_void()+
ggtitle('Predictions for Denver')
)
knitr::opts_chunk$set(echo = TRUE)
library(sf)
library(caret)
library(pscl)
library(plotROC)
library(pROC)
library(tidyverse)
library(terra)
library(kableExtra)
library(tigris)
library(viridis)
library(gridExtra)
calgary_boundary <- st_read('Data/calgary/CALGIS_CITYBOUND_LIMIT/CALGIS_CITYBOUND_LIMIT.shp') %>% st_transform('EPSG:3780')
inundation <- rast('Data/calgary/inundation/w001001.adf')
inundation <- project(inundation,'EPSG:3780') #Project innundation raster into correct cordinate system
grid <- st_make_grid(calgary_boundary,100,square=TRUE) %>%
st_sf() %>%
mutate(ID = row_number())
# Get just grid squares with centroid in Calgary city limits
grid <- grid %>%
st_centroid() %>%
st_join(.,calgary_boundary,join = st_intersects,left=FALSE) %>%
st_drop_geometry() %>%
left_join(.,grid,by='ID') %>%
st_as_sf() %>%
mutate(ID = row_number()) %>%
select(ID)
# Count the number of inundation cells in each grid square in fishnet
extract_values <- extract(inundation, grid) %>% #Assign each raster pixel to a grid square
group_by(ID,w001001) %>% tally() %>%
ungroup() %>%
pivot_wider(id_cols=ID,names_from=w001001,values_from=n) %>%
replace(is.na(.), 0) %>% #Replace NA with 0
filter(`NA` == 0) %>% #Filter out grid squares that do not have inundation data
# 1 and 2 are inundation, sum those together and sum 0 and 3 together for non_inundation
mutate(innundation = `1` + `2`,
non_innundate = `0` + `3` + `NA`,
in_id = as.factor(ifelse(innundation/(innundation + non_innundate) > 0.25,1,0))) %>% #If grid square is more than 25% inundate consider it inundate (i.e: 1)
select(ID,in_id)
grid2 <- right_join(grid,extract_values,by='ID')
# Make Map of inundated areas
ggplot()+
geom_sf(data=grid2,aes(fill=in_id),color='transparent')+
theme_void()
dem <- rast('Data/calgary/calgarydem/w001001.adf')
dem <- project(dem,'EPSG:3780')
elevation_extract <- terra::extract(dem,grid2,fun='mean',na.rm=TRUE) %>%
rename(elevation_mean = w001001) %>%
mutate(elevation = elevation_mean - min(elevation_mean))
grid3 <- cbind(grid2,elevation_extract %>% select(elevation))
#Need four land cover tiles to cover all of Calgary
land_cover1 <- rast('Data/calgary/worldcover/ESA_WorldCover_10m_2020_v100_N48W114_Map.tif')
land_cover2 <- rast('Data/calgary/worldcover/ESA_WorldCover_10m_2020_v100_N48W117_Map.tif')
land_cover3 <- rast('Data/calgary/worldcover/ESA_WorldCover_10m_2020_v100_N51W114_Map.tif')
land_cover4 <- rast('Data/calgary/worldcover/ESA_WorldCover_10m_2020_v100_N51W117_Map.tif')
calgary_land_cover <- terra::merge(land_cover1,land_cover2,land_cover3,land_cover4) #Merge together all land cover rasters that overlap Calgary
calgary_land_cover2 <- crop(calgary_land_cover, calgary_boundary %>% st_transform('EPSG:4326')) #Crop Raster to Calgary
grid4 <- grid3 %>% st_transform('EPSG:4326') #Project grid into WGS1984 so that I do not have to project the raster
mode <- function(class){
which.max(tabulate(class))
}
# Extract raster values within each polygon and determine the most common raster value
land_cover_values <- extract(calgary_land_cover2, grid4) %>%
rename(landcover = ESA_WorldCover_10m_2020_v100_N48W114_Map) %>%
group_by(ID) %>% summarise(landcover_mode = mode(landcover)) %>%
ungroup() %>%
select(landcover_mode)
grid5 <- cbind(grid4,land_cover_values) %>%
st_transform('EPSG:3780') %>%
mutate(landcover_mode = as.factor(landcover_mode))
water <- st_read('Data/calgary/Hydrology_20240320.geojson') %>% st_transform('EPSG:3780')
centroid <- grid5 %>%
st_centroid()
nearest_feat <- st_nearest_feature(centroid,water)
grid5$water_dist <- as.double(st_distance(centroid, water[nearest_feat,], by_element=TRUE))
calgary_slope <- terrain(dem, v="slope", neighbors=8, unit="degrees")
slope_extract <- terra::extract(calgary_slope,grid5, fun='max', na.rm=TRUE) %>%
rename(slope_max = slope)
grid6 <- cbind(grid5,slope_extract %>% select(slope_max))
calgary_fa <- rast('Data/calgary/calgary_flowaccumilation.tif')
calgary_fa <- project(calgary_fa,'EPSG:3780')
fa_extract <- terra::extract(calgary_fa,grid6, fun='max', na.rm=TRUE) %>%
rename(fa_max = calgary_flowaccumilation)
grid7 <- cbind(grid6,fa_extract %>% select(fa_max))
grid7$fa_log <- log(grid7$fa_max + 1)
create_map <- function(variable,title,color_scale,legend_label){
ggplot()+
geom_sf(data=grid7,aes(fill={{variable}}),color='transparent')+
scale_fill_viridis(option=color_scale,name=legend_label)+
ggtitle(title)+
theme_void()
}
m1 <- create_map(elevation,'Elevation Above Minimum City Elevation (meters)','rocket','elevation (meters')
m2 <- create_map(water_dist,'Distance to Water (meters)','plasma','distance (meters)')
m3 <- create_map(slope_max,'Slope','magma','Slope')
m4 <- create_map(fa_log,'Flow Accumilation (Natural Log)','cividis','Number of Pixels')
grid.arrange(m1,m2,m3,m4)
set.seed(3456)
trainIndex <- createDataPartition(grid7$landcover_mode, p = .70,
list = FALSE,
times = 1)
floodTrain <- grid7[ trainIndex,]
floodTest  <- grid7[-trainIndex,]
floodModel <- glm(in_id ~ .,
family="binomial"(link="logit"), data = floodTrain %>%
as.data.frame() %>%
select(-geometry, -ID, -fa_max))
summary(floodModel)
classProbs <- predict(floodModel, floodTest, type="response")
hist(classProbs)
testProbs <- data.frame(obs = as.factor(floodTest$in_id),
pred = classProbs)
ggplot(testProbs, aes(x = pred, fill=as.factor(obs))) +
geom_density() +
facet_grid(obs ~ .,scales = 'free') +
xlab("Probability") +
ylab("Frequency")+
geom_vline(xintercept = .5) +
scale_fill_manual(values = c("dark blue", "dark green"),
labels = c("Not flooded","flooded"),
name = "")+
theme_bw()
testProbs$predClass <- ifelse(testProbs$pred > .12 ,1,0)
caret::confusionMatrix(reference = as.factor(testProbs$obs),
data = as.factor(testProbs$predClass),
positive = "1")
auc <- round(auc(testProbs$obs, testProbs$pred),2)
ggplot(testProbs, aes(d = as.numeric(obs), m = pred)) +
geom_roc(n.cuts = 50, labels = FALSE,color='blue') +
annotate("text", x = 0.1, y = 1, label=paste("AUC: ",as.character(auc)),color='blue')+
style_roc(theme = theme_grey) +
geom_abline(slope = 1, intercept = 0, size = 1.5, color = 'grey')+
theme_bw()
ctrl <- trainControl(method = "cv",
number = 100,
p = 0.7,
savePredictions = TRUE)
cvFit <- train(as.factor(in_id) ~ .,  data = grid7 %>%
as.data.frame() %>%
select(-geometry, -ID,-fa_max),
method="glm", family="binomial",
trControl = ctrl)
cvFit
ggplot(as.data.frame(cvFit$resample), aes(Accuracy)) +
geom_histogram() +
scale_x_continuous(limits = c(0, 1)) +
labs(x="Accuracy",
y="Count")+
theme_bw()
floodtest1 <- cbind(floodTest,testProbs) %>%
mutate(type = case_when(obs == 0 & predClass == 0 ~ 'TN',
obs == 1 & predClass == 1 ~ 'TP',
obs == 1 & predClass == 0 ~ 'FN',
obs == 0 & predClass == 1 ~ 'FP'))
grid7 <- grid7 %>%
mutate(predict = predict(floodModel, grid7, type="response"),
outcome = as.factor(ifelse(predict > 0.12,1,0)))
dem_1 <- rast("Data/denver/n39_w105_1arc_v3.tif")
dem_2 <- rast("Data/denver/n39_w106_1arc_v32.tif")
merg_dem <- terra::merge(dem_1,dem_2)
merg_dem <- project(merg_dem, "EPSG:6427")
denver_bound <-
st_read("Data/denver/county_boundary") %>%
st_transform(crs = "EPSG:6427")
dem_crop <- crop(merg_dem, denver_bound)
# 'mask' out the values outside denver
denver_dem <- mask(dem_crop, denver_bound)
denver_slope <- terrain(denver_dem, v="slope", neighbors=8, unit="degrees")
grid_den <- st_make_grid(denver_bound,100,square=TRUE) %>%
st_sf() %>%
mutate(ID = row_number())
# Get just grid squares with centroid in Calgary city limits
grid_den <- grid_den %>%
st_centroid() %>%
st_join(.,denver_bound,join = st_intersects,left=FALSE) %>%
st_drop_geometry() %>%
left_join(.,grid_den,by='ID') %>%
st_as_sf() %>%
mutate(ID = row_number()) %>%
select(ID)
elevation_extract <- terra::extract(merg_dem,grid_den, fun='mean', na.rm=TRUE) %>%
rename(elevation_mean = n39_w105_1arc_v3) %>%
mutate(elevation = elevation_mean - min(elevation_mean))
grid3_den <- cbind(grid_den,elevation_extract %>% select(elevation))
den_slope_extract <- terra::extract(denver_slope,grid_den, fun='max', na.rm=TRUE) %>%
rename(slope_max = slope)
grid3_den <- cbind(grid3_den,den_slope_extract %>% select(slope_max))
#Need four land cover tiles to cover all of Calgary
land_cover1 <- rast('Data/denver/landcover/ESA_WorldCover_10m_2020_v100_N39W105_Map.tif')
land_cover2 <- rast('Data/denver/landcover/ESA_WorldCover_10m_2020_v100_N39W108_Map.tif')
denver_land_cover <- terra::merge(land_cover1,land_cover2) #Merge together all land cover rasters that overlap Calgary
denver_land_cover2 <- crop(denver_land_cover , denver_bound %>% st_transform('EPSG:4326')) #Crop Raster to Calgary
grid4_den <- grid3_den %>% st_transform('EPSG:4326') #Project grid into WGS1984 so that I do not have to project the raster
mode <- function(class){
which.max(tabulate(class))
}
# Extract raster values within each polygon and determine the most common raster value
land_cover_values <- extract(denver_land_cover2, grid4_den) %>%
rename(landcover = ESA_WorldCover_10m_2020_v100_N39W105_Map) %>%
group_by(ID) %>% summarise(landcover_mode = mode(landcover)) %>%
ungroup() %>%
select(landcover_mode)
grid5_den <- cbind(grid4_den,land_cover_values) %>%
st_transform('EPSG:6427') %>%
mutate(landcover_mode = as.factor(landcover_mode))
lakes_ponds <- st_read("Data/denver/lakes_and_ponds/") %>%
st_transform("EPSG:6427")
streams <- st_read("Data/denver/streams/") %>%
st_transform("EPSG:6427")
centroid <- grid5_den %>%
st_centroid()
nearest_feat <- st_nearest_feature(centroid,lakes_ponds)
grid5_den$lakes_ponds_dist <- as.double(st_distance(centroid, lakes_ponds[nearest_feat,], by_element=TRUE))
nearest_feat_streams <- st_nearest_feature(centroid,streams)
grid5_den$streams_dist <- as.double(st_distance(centroid, streams[nearest_feat_streams,], by_element=TRUE))
grid5_den$water_dist <- pmin(grid5_den$lakes_ponds_dist, grid5_den$streams_dist)
grid5_den <- grid5_den %>% select(-streams_dist,-lakes_ponds_dist)
denver_fa <- rast('Data/denver/denver_flow_accumilation.tif')
denver_fa <- project(denver_fa,'EPSG:6427')
fa_extract <- terra::extract(denver_fa,grid5_den, fun='max', na.rm=TRUE) %>%
rename(fa_max = denver_flow_accumilation)
grid6_den <- cbind(grid5_den,fa_extract %>% select(fa_max))
grid6_den$fa_log <- log(grid6_den$fa_max + 1)
grid6_den <- grid6_den %>%
mutate(prediction = predict(floodModel,grid6_den, type="response"),
outcome = as.factor(ifelse(prediction > 0.12, 1,0)))
grid.arrange(nrow=1,
ggplot()+
geom_sf(data=floodtest1,aes(fill=type),color='transparent')+
scale_fill_discrete(name='result type')+
theme_void()+
ggtitle('Results for Calgary Test Set'),
ggplot()+
geom_sf(data=grid7,aes(fill=outcome),color='transparent')+
scale_fill_manual(values=c('#fc9c9c','lightblue'),name='',labels=c('No Flood','Flood'))+
theme_void()+
ggtitle('Predictions for Calgary'),
ggplot()+
geom_sf(data=grid6_den,aes(fill=outcome),color='transparent')+
scale_fill_manual(values=c('#fc9c9c','lightblue'),name='',labels=c('No Flood','Flood'))+
theme_void()+
ggtitle('Predictions for Denver')
)
grid2 <- right_join(grid,extract_values,by='ID')
# Make Map of inundated areas
ggplot()+
geom_sf(data=grid2,aes(fill=in_id),color='transparent')+
scale_fill_manual(values=c('#fc9c9c','lightblue'),name='',labels=c('No Flood','Flood'))+
theme_void()
floodModel <- glm(in_id ~ .,
family="binomial"(link="logit"), data = floodTrain %>%
as.data.frame() %>%
select(-geometry, -ID, -fa_max))
sum <- summary(floodModel)
View(sum)
sum$coefficients %>%
kable() %>%
kable_minimal()
summary(floodModel)$coefficients %>%
kable() %>%
kable_minimal()
floodModel <- glm(in_id ~ .,
family="binomial"(link="logit"), data = floodTrain %>%
as.data.frame() %>%
select(-geometry, -ID, -fa_max))
summary(floodModel)$coefficients %>%
kable() %>%
kable_minimal()
classProbs <- predict(floodModel, floodTest, type="response")
hist(classProbs)
classProbs <- predict(floodModel, floodTest, type="response")
hist(classProbs,breaks=100)
testProbs <- data.frame(obs = as.factor(floodTest$in_id),
pred = classProbs)
ggplot(testProbs, aes(x = pred, fill=as.factor(obs))) +
geom_density() +
facet_grid(obs ~ .,scales = 'free') +
xlab("Probability") +
ylab("Frequency")+
geom_vline(xintercept = .5) +
scale_fill_manual(values = c("dark blue", "dark green"),
labels = c("Not flooded","flooded"),
name = "")+
theme_bw()
ggplot(testProbs, aes(x = pred, fill=as.factor(obs))) +
geom_histogram() +
facet_grid(obs ~ .,scales = 'free') +
xlab("Probability") +
ylab("Frequency")+
geom_vline(xintercept = .5) +
scale_fill_manual(values = c("dark blue", "dark green"),
labels = c("Not flooded","flooded"),
name = "")+
theme_bw()
testProbs <- data.frame(obs = as.factor(floodTest$in_id),
pred = classProbs)
ggplot(testProbs, aes(x = pred, fill=as.factor(obs))) +
geom_density() +
facet_grid(obs ~ .,scales = 'free') +
xlab("Probability") +
ylab("Frequency")+
geom_vline(xintercept = .5) +
scale_fill_manual(values = c("dark blue", "dark green"),
labels = c("Not flooded","flooded"),
name = "")+
theme_bw()
testProbs$predClass <- ifelse(testProbs$pred > .12 ,1,0)
caret::confusionMatrix(reference = as.factor(testProbs$obs),
data = as.factor(testProbs$predClass),
positive = "1")
auc <- round(auc(testProbs$obs, testProbs$pred),2)
ggplot(testProbs, aes(d = as.numeric(obs), m = pred)) +
geom_roc(n.cuts = 50, labels = FALSE,color='blue') +
annotate("text", x = 0.1, y = 1, label=paste("AUC: ",as.character(auc)),color='blue')+
style_roc(theme = theme_grey) +
geom_abline(slope = 1, intercept = 0, size = 1.5, color = 'grey')+
theme_bw()
auc <- round(auc(testProbs$obs, testProbs$pred),2)
ggplot(testProbs, aes(d = as.numeric(obs), m = pred)) +
geom_roc(n.cuts = 20, labels = TRUE,color='blue') +
annotate("text", x = 0.1, y = 1, label=paste("AUC: ",as.character(auc)),color='blue')+
style_roc(theme = theme_grey) +
geom_abline(slope = 1, intercept = 0, size = 1.5, color = 'grey')+
theme_bw()
auc <- round(auc(testProbs$obs, testProbs$pred),2)
ggplot(testProbs, aes(d = as.numeric(obs), m = pred)) +
geom_roc(n.cuts = 50, labels = FALSE,color='blue') +
annotate("text", x = 0.1, y = 1, label=paste("AUC: ",as.character(auc)),color='blue')+
style_roc(theme = theme_grey) +
geom_abline(slope = 1, intercept = 0, size = 1.5, color = 'grey')+
theme_bw()
ctrl <- trainControl(method = "cv", number = 50, classProbs = TRUE, savePredictions = TRUE, summaryFunction = twoClassSummary)
cvFit <- train(as.factor(in_id) ~ .,  data = grid7 %>%
as.data.frame() %>%
select(-geometry, -ID,-fa_max),
method="glm", family="binomial",
trControl = ctrl)
ctrl <- trainControl(method = "cv", number = 50, classProbs = TRUE, savePredictions = TRUE, summaryFunction = twoClassSummary)
cvFit <- train(as.factor(in_id) ~ .,  data = grid7 %>%
as.data.frame() %>%
select(-geometry, -ID,-fa_max),
data = data_2021_2,
method = "glm",
family = "binomial",
metric = "ROC",
trControl = ctrl
)
ctrl <- trainControl(method = "cv", number = 50, classProbs = TRUE, savePredictions = TRUE, summaryFunction = twoClassSummary)
cvFit <- train(as.factor(in_id) ~ .,  data = grid7 %>%
as.data.frame() %>%
select(-geometry, -ID,-fa_max),
method = "glm",
family = "binomial",
metric = "ROC",
trControl = ctrl
)
ctrl <- trainControl(method = "cv",
number = 100,
p = 0.7,
savePredictions = TRUE)
cvFit <- train(as.factor(in_id) ~ .,  data = grid7 %>%
as.data.frame() %>%
select(-geometry, -ID,-fa_max),
method="glm", family="binomial",
trControl = ctrl)
cvFit
ggplot(as.data.frame(cvFit$resample), aes(Accuracy)) +
geom_histogram() +
scale_x_continuous(limits = c(0, 1)) +
labs(x="Accuracy",
y="Count")+
theme_bw()
ctrl <- trainControl(method = "cv",
number = 100,
p = 0.7,
savePredictions = TRUE)
cvFit <- train(as.factor(in_id) ~ .,  data = grid7 %>%
as.data.frame() %>%
select(-geometry, -ID,-fa_max),
method="glm", family="binomial",
trControl = ctrl)
ggplot(as.data.frame(cvFit$resample), aes(Accuracy)) +
geom_histogram() +
scale_x_continuous(limits = c(0, 1)) +
labs(x="Accuracy",
y="Count")+
theme_bw()
ggplot(as.data.frame(cvFit$resample), aes(Accuracy)) +
geom_histogram(bins=100) +
scale_x_continuous(limits = c(0, 1)) +
labs(x="Accuracy",
y="Count")+
theme_bw()
grid.arrange(nrow=1,
ggplot()+
geom_sf(data=floodtest1,aes(fill=type),color='transparent')+
scale_fill_discrete(name='result type')+
theme_void()+
ggtitle('Results for Calgary Test Set'),
ggplot()+
geom_sf(data=grid7,aes(fill=outcome),color='transparent')+
scale_fill_manual(values=c('#fc9c9c','lightblue'),name='',labels=c('No Flood','Flood'))+
theme_void()+
ggtitle('Predictions for Calgary'),
ggplot()+
geom_sf(data=grid6_den,aes(fill=outcome),color='transparent')+
scale_fill_manual(values=c('#fc9c9c','lightblue'),name='',labels=c('No Flood','Flood'))+
theme_void()+
ggtitle('Predictions for Denver')
)
grid.arrange(nrow=1,
ggplot()+
geom_sf(data=floodtest1,aes(fill=type),color='transparent')+
scale_fill_manual(values=c('grey50','lightblue','lightgreen','purple'),name='',labels=c('False Negative','False Positive','True Negative','True Positive'))+
theme_void()+
ggtitle('Results for Calgary Test Set'),
ggplot()+
geom_sf(data=grid7,aes(fill=outcome),color='transparent')+
scale_fill_manual(values=c('#fc9c9c','lightblue'),name='',labels=c('No Flood','Flood'))+
theme_void()+
ggtitle('Predictions for Calgary'),
ggplot()+
geom_sf(data=grid6_den,aes(fill=outcome),color='transparent')+
scale_fill_manual(values=c('#fc9c9c','lightblue'),name='',labels=c('No Flood','Flood'))+
theme_void()+
ggtitle('Predictions for Denver')
)
grid.arrange(nrow=1,
ggplot()+
geom_sf(data=floodtest1,aes(fill=type),color='transparent')+
scale_fill_manual(values=c('grey50','blue','lightgreen','purple'),name='',labels=c('False Negative','False Positive','True Negative','True Positive'))+
theme_void()+
ggtitle('Results for Calgary Test Set'),
ggplot()+
geom_sf(data=grid7,aes(fill=outcome),color='transparent')+
scale_fill_manual(values=c('#fc9c9c','lightblue'),name='',labels=c('No Flood','Flood'))+
theme_void()+
ggtitle('Predictions for Calgary'),
ggplot()+
geom_sf(data=grid6_den,aes(fill=outcome),color='transparent')+
scale_fill_manual(values=c('#fc9c9c','lightblue'),name='',labels=c('No Flood','Flood'))+
theme_void()+
ggtitle('Predictions for Denver')
)
grid.arrange(nrow=1,
ggplot()+
geom_sf(data=floodtest1,aes(fill=type),color='transparent')+
scale_fill_manual(values=c('grey50','blue','lightgreen','purple'),name='',labels=c('False Negative','False Positive','True Negative','True Positive'))+
theme_void()+
ggtitle('Results for Calgary Test Set'),
ggplot()+
geom_sf(data=grid7,aes(fill=outcome),color='transparent')+
scale_fill_manual(values=c('#fc9c9c','lightblue'),name='',labels=c('No Flood','Flood'))+
theme_void()+
ggtitle('Predictions for Calgary')
)
ggplot()+
geom_sf(data=grid6_den,aes(fill=outcome),color='transparent')+
scale_fill_manual(values=c('#fc9c9c','lightblue'),name='',labels=c('No Flood','Flood'))+
theme_void()+
ggtitle('Predictions for Denver')
knitr::opts_chunk$set(echo = TRUE)
classProbs <- predict(floodModel, floodTest, type="response") %>% as.data.frame()
library(sf)
library(caret)
library(pscl)
library(plotROC)
library(pROC)
library(tidyverse)
library(terra)
library(kableExtra)
library(tigris)
library(viridis)
library(gridExtra)
classProbs <- predict(floodModel, floodTest, type="response") %>% as.data.frame()
ggplot(data=classProbs)+
geom_histogram(bins=100)
View(classProbs)
classProbs <- predict(floodModel, floodTest, type="response") %>% as.data.frame()
ggplot(data=classProbs,aes(.))+
geom_histogram(bins=100)
classProbs <- predict(floodModel, floodTest, type="response") %>% as.data.frame()
ggplot(data=classProbs,aes(.))+
geom_histogram(bins=100)+
theme_bw()
classProbs <- predict(floodModel, floodTest, type="response") %>% as.data.frame()
ggplot(data=classProbs,aes(.))+
geom_histogram(bins=100,color='orange')+
theme_bw()
classProbs <- predict(floodModel, floodTest, type="response") %>% as.data.frame()
ggplot(data=classProbs,aes(.))+
geom_histogram(bins=100,fill='orange')+
theme_bw()
ggplot(data=classProbs,aes(.))+
geom_histogram(bins=100,fill='orange')+
theme_bw()+
ylab('Count')
ggplot(data=classProbs,aes(.))+
geom_histogram(bins=100,fill='orange')+
theme_bw()+
ylab('Count')+
xlab('Probability')
