---
title: "calgary_work"
author: "Richard Barad"
date: "2024-03-22"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Import Libraries

```{r cars, results='hide'}
library(sf)
library(tidyverse)
library(terra)
library(kableExtra)
library(tigris)
library(viridis)
library(gridExtra)
```

# Data Setup for Calgary

Read Data for Calgary

```{r read_files, echo=FALSE}

calgary_boundary <- st_read('Data/calgary/CALGIS_CITYBOUND_LIMIT/CALGIS_CITYBOUND_LIMIT.shp') %>% st_transform('EPSG:3780')

inundation <- rast('Data/calgary/inundation/w001001.adf')

```
Make Grid

```{r}

inundation <- project(inundation,'EPSG:3780') #Project innundation raster into correct cordinate system

grid <- st_make_grid(calgary_boundary,100,square=TRUE) %>%
  st_sf() %>%
  mutate(ID = row_number())

# Get just grid squares with centroid in Calgary city limits

grid <- grid %>%
  st_centroid() %>%
  st_join(.,calgary_boundary,join = st_intersects,left=FALSE) %>%
  st_drop_geometry() %>%
  left_join(.,grid,by='ID') %>%
  st_as_sf() %>%
  mutate(ID = row_number()) %>%
  select(ID)

```

Summarize innundation data by grid square.

```{r}

# Count the number of innundation cells in each grid square in fishnet

extract_values <- extract(inundation, grid) %>% #Assign each raster pixel to a grid square
  group_by(ID,w001001) %>% tally() %>%
  ungroup() %>%
  pivot_wider(id_cols=ID,names_from=w001001,values_from=n) %>%
  replace(is.na(.), 0) %>% #Replace NA with 0
  filter(`NA` == 0) %>% #Filter out grid squares that do not have innundation data
  # 1 and 2 are innundation, sum thoose together and sum 0 and 3 together for non_inundation
  mutate(innundation = `1` + `2`,
         non_innundate = `0` + `3` + `NA`,
         in_id = as.factor(ifelse(innundation/(innundation + non_innundate) > 0.25,1,0))) %>% #If grid square is more than 25% innundate consider it innunduate (i.e: 1)
  select(ID,in_id)

```

Join extracted innundation data to grid squares, use right join to remove grid squares without innundation data.

```{r}

grid2 <- right_join(grid,extract_values,by='ID') 

# Make Map of innudated areas

ggplot()+
  geom_sf(data=grid2,aes(fill=in_id),color='transparent')+
  theme_void()

```

# Engineer Predictor Features for Calgary

Get zonal statistics for grid squares, calculate mean elevation for each.

```{r}

dem <- rast('Data/calgary/calgarydem/w001001.adf')

dem <- project(dem,'EPSG:3780')

elevation_extract <- terra::extract(dem,grid2,fun='mean',na.rm=TRUE) %>%
  rename(elevation_mean = w001001) %>%
  mutate(elevation = elevation_mean - min(elevation_mean))

grid3 <- cbind(grid2,elevation_extract %>% select(elevation))

```

Get Percent impermeable surface for each grid square. Prior to running this I repaired the geometries in ArcGIS Pro as reparing geometries in R was extremely slow.

```{r}

permiable <- st_read('Data/calgary/local_land_Cover/landcover.shp') %>%
  filter(ldscmetric != 'Impermable') %>%
  st_transform('EPSG:3780')

grid_perm_int <- st_intersection(grid3,permiable)

grid_perm_int <- grid_perm_int %>%
  mutate(area = round(as.numeric(st_area(grid_perm_int)),2)) %>%
  st_drop_geometry() %>%
  group_by(ID) %>% summarise(perm_area = sum(area))

grid4 <- left_join(grid3,grid_perm_int,by='ID') %>%
  mutate(perm_area = replace_na(perm_area,0),
         pct_perm = round(perm_area/as.numeric(st_area(.))*100,2)) %>%
  select(-perm_area)

rm(grid_perm_int)
```
Summarize land cover data by grid square and figure out the mode land cover class for each grid square

```{r}
#Need four land cover tiles to cover all of Calgary
land_cover1 <- rast('Data/calgary/worldcover/ESA_WorldCover_10m_2020_v100_N48W114_Map.tif')
land_cover2 <- rast('Data/calgary/worldcover/ESA_WorldCover_10m_2020_v100_N48W117_Map.tif')
land_cover3 <- rast('Data/calgary/worldcover/ESA_WorldCover_10m_2020_v100_N51W114_Map.tif')
land_cover4 <- rast('Data/calgary/worldcover/ESA_WorldCover_10m_2020_v100_N51W117_Map.tif')

calgary_land_cover <- terra::merge(land_cover1,land_cover2,land_cover3,land_cover4) #Merge together all land cover rasters that overlap Calgary

calgary_land_cover2 <- crop(calgary_land_cover, calgary_boundary %>% st_transform('EPSG:4326')) #Crop Raster to Calgary

grid5 <- grid4 %>% st_transform('EPSG:4326') #Project grid into WGS1984 so that I do not have to project the raster

mode <- function(class){
  which.max(tabulate(class))
}

# Extract raster values within each polygon and determine the most common raster value
land_cover_values <- extract(calgary_land_cover2, grid5) %>%
  rename(landcover = ESA_WorldCover_10m_2020_v100_N48W114_Map) %>%
  group_by(ID) %>% summarise(landcover_mode = mode(landcover)) %>%
  ungroup() %>%
  select(landcover_mode)

grid6 <- cbind(grid5,land_cover_values) %>% 
  st_transform('EPSG:3780') %>%
  mutate(landcover_mode = as.factor(landcover_mode))

```
Distance to Water - Used some code from PPA.

```{r}

water <- st_read('Data/calgary/Hydrology_20240320.geojson') %>% st_transform('EPSG:3780')

centroid <- grid6 %>%
  st_centroid()

nearest_feat <- st_nearest_feature(centroid,water)

grid6$water_dist <- as.double(st_distance(centroid, water[nearest_feat,], by_element=TRUE))

```

```{r cal_slope}
calgary_boundary <- st_read('Data/calgary/CALGIS_CITYBOUND_LIMIT/CALGIS_CITYBOUND_LIMIT.shp') %>% st_transform('EPSG:3780')

cal_dem <- raster('Data/calgary/calgarydem/w001001.adf') %>%
  projectRaster(cal_dem, crs = 'EPSG:3780')



calgary_slope <- terrain(cal_dem, v="slope", neighbors=8, unit="degrees")  

plot(calgary_slope)
```

